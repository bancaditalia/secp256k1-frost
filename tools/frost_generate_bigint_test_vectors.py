#!/usr/bin/env python3
#
# Copyright (c) 2025 Bank of Italy
# Distributed under the MIT software license, see the accompanying
# file COPYING or https://www.opensource.org/licenses/mit-license.php.

"""Print on stdout an .h file with test vectors for the bigint library used by
FROST.
"""

import pathlib
import sys
from collections.abc import Iterator

SECP256K1_P = int("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F", 16)

PREAMBLE = f"""\
/***********************************************************************
 * Copyright (c) 2025 Bank of Italy                                    *
 * Distributed under the MIT software license, see the accompanying    *
 * file COPYING or https://www.opensource.org/licenses/mit-license.php.*
 ***********************************************************************/

/* Note: this file was autogenerated using {pathlib.Path(__file__).name}. Do not edit. */

#ifndef SECP256K1_MODULE_FROST_TESTS_BIGINT_MOD_P_H
#define SECP256K1_MODULE_FROST_TESTS_BIGINT_MOD_P_H

/* ************ Test Vector for testing bigint functionality ********** */

#include "../bigint.h"

"""

SUFFIX = "#endif /* SECP256K1_MODULE_FROST_TESTS_BIGINT_MOD_P_H */"

tests = [
    ("0", 0),
    ("1", 1),
    ("p - 1", SECP256K1_P - 1),
    ("p", SECP256K1_P),
    ("p + 1", SECP256K1_P + 1),
    ("2 * p", 2 * SECP256K1_P),
    # Additional edge cases
    ("p - 2", SECP256K1_P - 2),
    ("p + 2", SECP256K1_P + 2),
    ("3 * p", 3 * SECP256K1_P),
    ("p^2 mod p (should be 0)", SECP256K1_P * SECP256K1_P),
    # Large number that requires multiple reduction steps
    ("2^384 - 1", (1 << 384) - 1),
    # Random 48-byte value (typical for hash-to-field)
    ("random 48-byte", int("123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef", 16)),
]


def bigint_to_limbs(x: int) -> tuple[int, ...]:
    """Return x as a tuple of uint64_t limbs (little-endian)."""
    limbs = []
    while x > 0:
        limbs.append(x & 0xFFFFFFFFFFFFFFFF)
        x >>= 64
    return tuple(limbs or [0])


def int_to_be_bytes(x: int) -> bytes:
    """Convert integer x to a 32-byte big-endian array."""
    return x.to_bytes(32, "big")


def reduce_bigint_mod_p_tests() -> Iterator[tuple[str, tuple[int, ...], bytes]]:
    """Generate test cases for reduce_bigint_mod_p function."""
    for name, val in tests:
        limbs = bigint_to_limbs(val)
        reduced = val % SECP256K1_P
        output = int_to_be_bytes(reduced)
        yield f"input = {name}", limbs, output


def verify_test_case(name: str, limbs: tuple[int, ...], expected_output: bytes) -> bool:
    """Verify that a test case is mathematically correct."""
    # Reconstruct the original value from limbs
    original_value = sum(limb << (64 * i) for i, limb in enumerate(limbs))

    # Compute expected reduction
    expected_reduced = original_value % SECP256K1_P
    expected_bytes = int_to_be_bytes(expected_reduced)

    # Verify
    if expected_bytes != expected_output:
        print(f"ERROR in {name}:", file=sys.stderr)
        print(f"  Original: {hex(original_value)}", file=sys.stderr)
        print(f"  Expected reduced: {hex(expected_reduced)}", file=sys.stderr)
        print(f"  Generated output: {expected_output.hex()}", file=sys.stderr)
        print(f"  Computed output:  {expected_bytes.hex()}", file=sys.stderr)
        return False

    return True


def format_c_limbs(limbs: tuple[int, ...]) -> str:
    """Format limbs as C array initializer."""
    if len(limbs) <= 4:
        # Short format for small arrays
        return "{" + ", ".join(f"0x{l:016x}" for l in limbs) + "}"
    # Multi-line format for large arrays
    formatted = "{\n    "
    for i, limb in enumerate(limbs):
        if i > 0 and i % 4 == 0:
            formatted += ",\n    "
        elif i > 0:
            formatted += ", "
        formatted += f"0x{limb:016x}"
    formatted += "\n  }"
    return formatted


def format_c_bytes(output: bytes) -> str:
    """Format bytes as C array initializer."""
    formatted = "{\n    "
    for i, byte in enumerate(output):
        if i > 0 and i % 12 == 0:
            formatted += ",\n    "
        elif i > 0:
            formatted += ", "
        formatted += f"0x{byte:02x}"
    formatted += "\n  }"
    return formatted


if __name__ == "__main__":
    print(PREAMBLE)

    for index, (name, limbs, output) in enumerate(reduce_bigint_mod_p_tests()):
        # verify test case
        if not verify_test_case(name, limbs, output):
            msg = f"The generation of this test case failed: {name=}, {limbs=}, {output=}"
            raise RuntimeError(msg)

        print(f"/* test case {index}: {name} */")
        print(f"static bigint_internal test_case_input_{index} = {{")
        print(f"  {format_c_limbs(limbs)},")
        print(f"  {len(limbs)}")
        print("};")
        print(f"static unsigned char expected_output_{index}[32] = {format_c_bytes(output)};\n")

    sep = ",\n    "
    print(f"""\

static int bigint_mod_p_test_vector_total_tests = {index + 1};

static bigint_internal* test_case_inputs[] = {{{sep.join(f"&test_case_input_{i}" for i in range(len(tests)))}}};
static unsigned char* expected_outputs[] = {{{sep.join(f"expected_output_{i}" for i in range(len(tests)))}}};

{SUFFIX}
""")
