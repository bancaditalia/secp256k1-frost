#!/usr/bin/env python3
# Copyright (c) 2023 Bank of Italy
# Distributed under the MIT software license, see the accompanying
# file COPYING or https://www.opensource.org/licenses/mit-license.php.
#
# These are not official test vectors, but has been generated and tested
# against the official implementation of hash-to-curve developed in go:
# https://github.com/armfazh/h2c-go-ref/
# https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve

"""
Generate a C file with test vectors for the 3-isogeny map
used in hash-to-curve (RFC 9380).

Usage:
> python tools/test_vectors_h2c_isomap_generate.py > src/modules/frost/vectors/ietf_h2c_iso3map_test_vectors.h
"""

from hashlib import sha256

# number of test vectors
N = 5

# Constants
p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F

# Coefficients from RFC 9380
k = {
    (1, 0): 0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7,
    (1, 1): 0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581,
    (1, 2): 0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262,
    (1, 3): 0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c,
    (2, 0): 0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b,
    (2, 1): 0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14,
    (3, 0): 0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c,
    (3, 1): 0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3,
    (3, 2): 0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931,
    (3, 3): 0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84,
    (4, 0): 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b,
    (4, 1): 0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573,
    (4, 2): 0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f
}


def modinv(a, p):
    return pow(a, -1, p)


def to_bytes32(x):
    return x.to_bytes(32, byteorder='big')


def fe(x):  # Field element
    return x % p


def iso_map(xp, yp):
    x1 = fe(xp)
    x2 = fe(x1 * x1)
    x3 = fe(x1 * x2)

    # x_num = k13 * x3 + k12 * x2 + k11 * x1 + k10
    x_num = fe(
        k[(1, 3)] * x3 +
        k[(1, 2)] * x2 +
        k[(1, 1)] * x1 +
        k[(1, 0)]
    )

    # x_den = x2 + k21 * x1 + k20
    x_den = fe(
        x2 +
        k[(2, 1)] * x1 +
        k[(2, 0)]
    )

    x = fe(x_num * modinv(x_den, p))

    # y_num = k33 * x3 + k32 * x2 + k31 * x1 + k30
    y_num = fe(
        k[(3, 3)] * x3 +
        k[(3, 2)] * x2 +
        k[(3, 1)] * x1 +
        k[(3, 0)]
    )

    # y_den = x3 + k42 * x2 + k41 * x1 + k40
    y_den = fe(
        x3 +
        k[(4, 2)] * x2 +
        k[(4, 1)] * x1 +
        k[(4, 0)]
    )

    y = fe(yp * y_num * modinv(y_den, p))
    return x, y


# Example: hash input to x-coordinate (not secure, but deterministic for testing)
def example_point(seed: bytes):
    h = int.from_bytes(sha256(seed).digest(), 'big') % p
    while True:
        x = h
        rhs = (x ** 3 + 7) % p
        y = pow(rhs, (p + 1) // 4, p)
        if pow(y, 2, p) == rhs:
            return x, y
        h = (h + 1) % p


def to_c_array(x: int) -> str:
    return '{ ' + ', '.join(f'0x{b:02x}' for b in x.to_bytes(32, 'big')) + ' }'


def to_go_byte_array(x: int):
    return '[]byte{' + ', '.join(f'0x{b:02x}' for b in x.to_bytes(32, 'big')) + '}'


print("/* Note: this file was autogenerated using test_vectors_ietf_isomap_generate.py. Do not edit. */")
print("")
print("#ifndef FROST_VECTORS_H2C_ISOMAP_TEST_VECTORS_H")
print("#define FROST_VECTORS_H2C_ISOMAP_TEST_VECTORS_H")
print("")
print(f"#define IETF_H2C_ISO3MAP_NUM_TEST_VECTORS {N}")
print("""
typedef struct {
    unsigned char xp[32], yp[32];
    unsigned char x[32], y[32];
} iso3_test_vector;
""")

print(f"static const iso3_test_vector iso3_test_vectors[IETF_H2C_ISO3MAP_NUM_TEST_VECTORS] = {{")
# Generate test vectors
for i in range(N):
    seed = f"test-{i}".encode()
    xp, yp = example_point(seed)
    x, y = iso_map(xp, yp)
    print(f"    {{")
    print(f"        {to_c_array(xp)},")
    print(f"        {to_c_array(yp)},")
    print(f"        {to_c_array(x)},")
    print(f"        {to_c_array(y)},")
    print(f"    }},")
print(f"}};")
print("")
print("#endif /* FROST_VECTORS_H2C_ISOMAP_TEST_VECTORS_H */")
