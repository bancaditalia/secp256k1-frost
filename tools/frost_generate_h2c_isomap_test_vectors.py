#!/usr/bin/env python3
#
# Copyright (c) 2025 Bank of Italy
#
# Distributed under the MIT software license, see the accompanying
# file COPYING or https://www.opensource.org/licenses/mit-license.php.
#
# These are not official test vectors, but they have been generated and tested
# against the official implementation of hash-to-curve developed in go:
# https://github.com/armfazh/h2c-go-ref/
# https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve

"""
Generate a C file with test vectors for the 3-isogeny map used in hash-to-curve (RFC 9380).

Usage:
$ tools/frost_generate_h2c_isomap_test_vectors.py > src/modules/frost/vectors/ietf_h2c_iso3map_test_vectors.h
"""

import pathlib
from hashlib import sha256

# number of test vectors
N = 5

# Constants
p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F

# Coefficients from RFC 9380
k = {
    (1, 0): 0x8E38E38E38E38E38E38E38E38E38E38E38E38E38E38E38E38E38E38DAAAAA8C7,
    (1, 1): 0x7D3D4C80BC321D5B9F315CEA7FD44C5D595D2FC0BF63B92DFFF1044F17C6581,
    (1, 2): 0x534C328D23F234E6E2A413DECA25CAECE4506144037C40314ECBD0B53D9DD262,
    (1, 3): 0x8E38E38E38E38E38E38E38E38E38E38E38E38E38E38E38E38E38E38DAAAAA88C,
    (2, 0): 0xD35771193D94918A9CA34CCBB7B640DD86CD409542F8487D9FE6B745781EB49B,
    (2, 1): 0xEDADC6F64383DC1DF7C4B2D51B54225406D36B641F5E41BBC52A56612A8C6D14,
    (3, 0): 0x4BDA12F684BDA12F684BDA12F684BDA12F684BDA12F684BDA12F684B8E38E23C,
    (3, 1): 0xC75E0C32D5CB7C0FA9D0A54B12A0A6D5647AB046D686DA6FDFFC90FC201D71A3,
    (3, 2): 0x29A6194691F91A73715209EF6512E576722830A201BE2018A765E85A9ECEE931,
    (3, 3): 0x2F684BDA12F684BDA12F684BDA12F684BDA12F684BDA12F684BDA12F38E38D84,
    (4, 0): 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFF93B,
    (4, 1): 0x7A06534BB8BDB49FD5E9E6632722C2989467C1BFC8E8D978DFB425D2685C2573,
    (4, 2): 0x6484AA716545CA2CF3A70C3FA8FE337E0A3D21162F0D6299A7BF8192BFD2A76F,
}


def modinv(a, p):
    return pow(a, -1, p)


def to_bytes32(x):
    return x.to_bytes(32, byteorder="big")


def fe(x):  # Field element
    return x % p


def iso_map(xp, yp):
    x1 = fe(xp)
    x2 = fe(x1 * x1)
    x3 = fe(x1 * x2)

    # x_num = k13 * x3 + k12 * x2 + k11 * x1 + k10
    x_num = fe(k[(1, 3)] * x3 + k[(1, 2)] * x2 + k[(1, 1)] * x1 + k[(1, 0)])

    # x_den = x2 + k21 * x1 + k20
    x_den = fe(x2 + k[(2, 1)] * x1 + k[(2, 0)])

    x = fe(x_num * modinv(x_den, p))

    # y_num = k33 * x3 + k32 * x2 + k31 * x1 + k30
    y_num = fe(k[(3, 3)] * x3 + k[(3, 2)] * x2 + k[(3, 1)] * x1 + k[(3, 0)])

    # y_den = x3 + k42 * x2 + k41 * x1 + k40
    y_den = fe(x3 + k[(4, 2)] * x2 + k[(4, 1)] * x1 + k[(4, 0)])

    y = fe(yp * y_num * modinv(y_den, p))
    return x, y


# Example: hash input to x-coordinate (not secure, but deterministic for testing)
def example_point(seed: bytes):
    h = int.from_bytes(sha256(seed).digest(), "big") % p
    while True:
        x = h
        rhs = (x**3 + 7) % p
        y = pow(rhs, (p + 1) // 4, p)
        if pow(y, 2, p) == rhs:
            return x, y
        h = (h + 1) % p


def to_c_array(x: int) -> str:
    return "{ " + ", ".join(f"0x{b:02x}" for b in x.to_bytes(32, "big")) + " }"


def to_go_byte_array(x: int):
    return "[]byte{" + ", ".join(f"0x{b:02x}" for b in x.to_bytes(32, "big")) + "}"


print(f"/* Note: this file was autogenerated using {pathlib.Path(__file__).name}. Do not edit. */")
print()
print("#ifndef FROST_VECTORS_H2C_ISOMAP_TEST_VECTORS_H")
print("#define FROST_VECTORS_H2C_ISOMAP_TEST_VECTORS_H")
print("""
typedef struct {
    unsigned char xp[32], yp[32];
    unsigned char x[32], y[32];
} iso3_test_vector;
""")

print("static const iso3_test_vector iso3_test_vectors[] = {")
# Generate test vectors
for i in range(N):
    seed = f"test-{i}".encode()
    xp, yp = example_point(seed)
    x, y = iso_map(xp, yp)
    print("    {")
    print(f"        {to_c_array(xp)},")
    print(f"        {to_c_array(yp)},")
    print(f"        {to_c_array(x)},")
    print(f"        {to_c_array(y)},")
    print("    },")
print("};")
print()
print("#endif /* FROST_VECTORS_H2C_ISOMAP_TEST_VECTORS_H */")
